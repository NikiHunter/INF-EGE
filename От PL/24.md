# 24 ЗАДАНИЕ. ШАБЛОНЫ
1. РАЗБИЕНИЕ СТРОКИ
```python
s = open('24-157.txt').readline()
s = s.replace('ST', 'S T')
print(max(len(c) for c in s.split()))
```
-----------------
```python
s = open('24-157.txt').readline()
while 'PPP' in s:
    s = s.replace('PPP', 'PP PP')
print(max(len(c) for c in s.split()))
```
```python
s = open('24-196.txt').readline()
s = s.replace('ZX', '*').replace('ZY', '*')
s = s.replace('X', ' ').replace('Y', ' ').replace('Z', ' ')
print(max(len(c) for c in s.split()))
```
-----------------
```python
s = open('24_9845.txt').readline()
s = s.replace('B', 'A').replace('C', 'A').replace('9', '8')
while 'AA' in s: s = s.replace('AA', 'A A')
while '88' in s: s = s.replace('88', '8 8')
print(max(len(c) for c in s.split()))
```
-----------------
```py
s = open('file.txt').readline()
s = s.split('A')
res = []
for i in range(len(s)-3):
    c = s[i]+'A'+s[i+1]+'A'+s[i+2]+'A'+s[i+3]
    #если букв МНОГО
    #с = 'A'.join(s[i:i+4])
    res.append(c)
print(max(res))
```
-----------------
```python
s = open('file.txt').readline()
s = s.split('A')
m = 10000000
for i in range(len(s)-35):
    #склеиваем 36 кусков (между ними 35 А) 
    c = 'A'.join(s[i:i+36])
    #вычитаем ненужные куски, так как ищем МИНИМАЛЬНОЕ кол-во
    m = min(m, len(c) - len(s[i] - len(s[i+35])))
print(m)
```
2. ДИНАМИЧЕСКИЙ ПОДСЧЁТ
```python
s = open('k7a-3.txt').readline()

m = [0]*len(s)

for i in range(1, len(s)):
    if s[i] in 'ACDF':
        m[i] = m[i-1] + 1
print(max(m))
```
-----------------
```py
s = open('k8-4.txt').readline()
m = [1]*len(s)

for i in range(1, len(s)):
    if s[i]!=s[i-1]:
        m[i] = m[i-1]+1
print(max(m))
```

## 24 ЗАДАНИЕ. ДВОЙНОЙ ЦИКЛ
1. БАЗОВЫЙ ДВОЙНОЙ ЦИКЛ
```py
s = open('k7a-4.txt').readline()
m = 0 
for l in range(len(s)):
    for r in range(l+m, len(s)): # оптимизируем с помощью m
        c = s[l:r+1]
        if 'D' not in c:
            m = max(m, len(c))
        else:
            break
print(m)
```
2. ДВОЙНОЙ ЦИКЛ С ЗАМЕНОЙ
```py
s = open('24-264.txt').readline()
m = 0
for c in 'QWERTYUIOPASDFGHJKLZXCVBNM':
    s = s.replace(c, 'A')
for c in '0123456789':
    s = s.replace(c, '0')
for l in range(len(s)):
    for r in range(l+m, len(s)):
        c = s[l:r+1]
        if 'AA' not in c and '00' not in c:
            m = max(m, len(c))
        else:
            break
print(m)
```
3. ЛЮБЫЕ ДВА ПОДРЯД ИДУЩИХ СИМВОЛА РАЗЛИЧНЫ (АЛФАВИТНЫЙ ПОРЯДОК)
```py
s = open('24-263.txt').readline()
m = 0
for l in range(len(s)):
    for r in range(l+m, len(s)):
        c = s[l:r+1]
        if all(c[i] != c[i+1] for i in range(len(c)-1)):
            m = max(m, len(c))
        else:
            break
print(m)
```
4. ТРОЙКА НЕ ЗАПИСАНА ДВА РАЗА ПОДРЯД
```py
s = open('24-173.txt').readline()
m = 0
for l in range(len(s)):
    for r in range(l+m, len(s)):
        c = s[l:r+1]
        if all((c[i] + c[i+1] + c[i+2]) != (c[i+3] + c[i+4] + c[i+5]) for i in range(len(c)-5)):
            m = max(m, len(c))
        else:
            break
print(m)
```
5. МАКС. КОЛ-ВО ИДУЩИХ ПОДРЯД ПАР СИМВОЛОВ
```py
s = open('24-196.txt').readline()
m = 0
for l in range(len(s)):
    for r in range(l+m, len(s)):
        c = s[l:r+1]
        if len(c)%2==0:
            if all(((c[i] + c[i+1] == 'ZX') or (c[i] + c[i+1] == 'ZY')) for i in range(0, len(c), 2)):
                m = max(len(c), m)
            else:
                break
print(m//2) # не забыть поделить на 2, т.к. ищем пары!!!
```
6. СРЕДИ КОТОРЫХ БУКВА ВСТРЕЧАЕТСЯ БОЛЕЕ ...
```py
s = open('24-1.txt').readline()
m = 0
for l in range(len(s)):
    for r in range(l+m, len(s)):
        c = s[l:r+1]
        if c.count('A') <= 5:
            m = max(m, len(c))
        else:
            break
print(m)
```
7. БУКВЫ ВСТРЕЧАЮТСЯ РОВНО/НЕ БОЛЕЕ ... РАЗ
```py
s = open('24-280.txt').readline()
m = 0
for l in range(len(s)):
    for r in range(l+m, len(s)):
        c = s[l:r+1]
        if c.count('X') == 5 and c.count('Y') == 5 and c.count('Z') == 5:
            m = max(m, len(c))
        elif c.count('X') > 5 or c.count('Y') > 5 or c.count('Z') > 5:
            break
print(m)
```
----------------------------------
```py
s = open('24-280.txt').readline()
m = 0
for l in range(len(s)):
    for r in range(l+m, len(s)):
        c = s[l:r+1]
        if all(c.count(i) <= 8 for i in 'AEIOUY') and all(c.count(j)==0 for j in 'VXZ'):
            m = max(m, len(c))
        else:
            break
print(m)
```
8. МИН. КОЛ-ВО СИМВОЛОВ, СРЕДИ КОТОРЫХ ...
```py
s = open('24-250.txt').readline()
m = 10000
for l in range(len(s)):
    for r in range(l, l+m):
        c = s[l:r+1]
        if c.count('.') == 7:
            m = min(m, len(c))
            break
print(m)
```
9. AF-подстроки
```py
s = open('24-153.txt').readline()
m = 10000
for l in range(len(s)):
    for r in range(l, l+m):
        c = s[l:r+1]
        if len(c)>2:
            if c[0]!='A':
                break
            if c[0] == 'A' and c[-1] == 'F':
                m = min(m, len(c))
                break
print(m)
```
10. СИМВОЛ ВСТРЕЧАЕТСЯ НЕ МЕНЕЕ ... РАЗ (ПЕРЕБОР С КОНЦА)
```py
s = open('24-263.txt').readline()
m = 10000
for l in range(len(s)):
    for r in range(l+m, l, -1):
        c = s[l:r+1]
        if c.count('Z') >= 120:
            m = min(m, len(c))
        else:
            break
print(m)
```
11. ПОДСТРОКА МОЖЕТ ЯВЛЯТЬСЯ ЗАПИСЬЮ В 16-РИЧНОЙ
```py
s = open('24-264.txt').readline()
for c in 'QWRTYUIOPSGHJKLZXVNM':
    s = s.replace(c, '*')
m = 0
for l in range(len(s)):
    for r in range(l+m, len(s)):
        c = s[l:r+1]
        if c.count('*') == 0 and c[0] != '0':
            m = max(m, len(c))
        else:
            break
print(m)
```

# 24 ЗАДАНИЕ. РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ
+ МОДУЛЬ RE
> finditer(паттерн, строка)
> Использовать неэкранированные строки: r"[a-z]+\.[a-z]+"

+ КВАНТИФИКАТОРЫ
> * ноль или больше:  А* — пустота или буквы А
> + один или больше:  A+ — буквы А (от 1 до беск.)
> {3} ровно три:  A{5} — AAAAA
> {4, 8} от четырех до восьми:  A{2, 4} — AA, AAA, AAAA

+ СИМВОЛЬНЫЕ КЛАССЫ
> [ABC] один из символов A, B, C:  [ABC]{4} — BCAA, CABB
> [A-Z] один символ от A до Z:  [0-9]{3} — 132, 234, 948, 607
> [^CDE] не C, не D, не E
> 
> . — любой произвольный символ:  .A  -  BA, DA, fA, AA
> 
> ВАЖНО: если служебные символы проверяются как обычные, то перед ними нужно поставить \ (например \. \+ \{ и т. д.)

+ СКОБОЧНЫЕ ГРУППЫ:
> () - группировка символов (запоминающие скобки)
> [AB]+ — символы A или И идут подряд
> (AB)+ — пары AB идут подряд
> (?=(...)) — поиск всех возможных совпадений (даже пересечений!!)

+ ПЕРЕЧИСЛЕНИЯ
> AB|CD|DE — AB или CD или DE

1. СИМВОЛЫ A, B, C (в произ. порядке)
```py
from re import *
s = open('k7a-1.txt').readline()
reg = r'[ABC]+'
print(max([len(x.group()) for x in finditer(reg, s)]))
```
2. МАКС КОЛ-ВО ИДУЩИХ ПОДРЯД ПАР ...
```py
from re import *
s = open('24-196.txt').readline()
reg = r'(ZX|ZY)+'
print(max([len(x.group())//2 for x in finditer(reg, s)]))
# не забываем в парах делить длину пополам
```
------------------------------------
```py
from re import *
s = open('24-212.txt').readline()
reg = r'([BCD][AO])+'
print(max(len(x.group())//2 for x in finditer(reg, s )))
```
3. ПОИСК ПАР С ПЕРЕСЕЧЕНИЯМИ 
```py
from re import *
s = open('24-204.txt').readline()
reg = rf'(?=((AA|CC)+))'
print(max([len(x.group(1))//2 for x in finditer(reg, s)]))
```
--------------------------------
```py
from re import *
s = open('24-215.txt').readline()
reg = r'(?=(([123][ABC][123])+))'
print(max(len(x.group(1))//3 for x in finditer(reg, s)))
```
4. ПОИСК С ПОДВОХОМ!!!
```py
from re import *
s = open('24-239.txt').readline()
reg = r'(?=((YZZ|XY|YZ)+))' # ищем сначала YZZ, а не YZ (важен порядок)
print(max(len(x.group(1)) for x in finditer(reg, s)))
```
5. МАКС ДЛИНА CACACA.. (на конце может быть и CA, и C)
```py
from re import *
s = open('24_5171.txt').readline()
reg = r'((CA)+)|((CA)+C)'
print(max([len(x.group()) for x in finditer(reg, s)]))
```
6. ВЕЩЕСТВ&ВЕЩЕСТВ
```py
from re import *
s = open('24_18597.txt').readline()
reg = r'[1-9][0-9]{3}\.[0-9]+&[1-9][0-9]{3}\.[0-9]+'
print(len(max([x.group() for x in finditer(reg, s)], key=len)))
```
7. БАЗОВЫЕ АРИФМЕТИЧЕСКИЕ ВЫРАЖЕНИЯ
```py
from re import *
s = open('24-298.txt').readline()
num = r'([1-9][0-9]*)'
reg = rf'{num}([-*]{num})+'
m = max([x.group() for x in finditer(reg, s)], key=len)
print(len(m), m)
```
8. АРИФМ. ВЫР. С НЕОТРИЦАТЕЛЬНЫМИ ЧИСЛАМИ
```py
from re import *
s = open('24-310.txt').readline()
num = r'([12][012]*|0)'
reg = rf'{num}([+*]{num})+'
m = max([x.group() for x in finditer(reg, s)], key=len)
print(len(m), m)
```
9. АРИФМ. ВЫР. РАВНО 0
```py
from re import *
s = open('24-299.txt').readline()
num = r'([1-9][0-9]*|0)'
mult = rf'({num}\*)*0(\*{num})*'
reg = rf'{mult}(\+{mult})*'
m = max([x.group() for x in finditer(reg, s)], key=len)
print(len(m), m)
```
10. ЦЕЛЫЕ НЕОТРИЦ. КРАТНЫЕ 5
```py
from re import *
s = open('24_19970.txt').readline()
num = r'([1-9][0-9]*[05]|0|5)'
reg = rf'{num}([+*]{num})+'
print(max([len(x.group()) for x in finditer(reg, s)]))
```

## 24 ЗАДАНИЕ. ДВА УКАЗАТЕЛЯ (не решаются через дефолт)
1. БОЛЬШОЙ ПЕРЕБОР НА МИН ЧИСЛО
```py
s = open('24_11954.txt').readline()
m = 1000000
l = k = 0
for r in range(len(s)):
    if s[r] == 'X': k+=1
    if s[r] == 'Y':
        k = 0
        l = r + 1  
    while k >= 500:
        m = min(m, r-l+1)
        if s[l] == 'X': k-=1
        l+=1
print(m)
```
