# 16 ЗАДАНИЕ. ШАБЛОНЫ
1. БАЗОВАЯ РЕКУРСИЯ
```py
def f(n: int) -> int:
    if n == 1:
        return 1
    if n > 1:
        return 2 * f(n - 1) + n + 3


print(f(19))
```
2. ДВЕ ФУНКЦИИ
```py
def f(n: int) -> int:
    if n == 1:
        return 1
    if n > 1:
        return 3 * f(n - 1) + g(n - 1) - n + 5


def g(n: int) -> int:
    if n == 1:
        return 1
    if n > 1:
        return f(n - 1) + 3 * g(n - 1) - 3 * n


print(f(14) + g(14))
```
3. МЕМОИЗАЦИЯ
```py
from functools import lru_cache


@lru_cache(None)  # использование кэша для хранения значений f(n)
def f(n: int) -> int:
    if n < -100000:
        return 1
    if n > 10:
        return f(n - 1) + 3 * f(n - 3) + 2
    return -f(n - 1)


# предварительный подсчёт f(n) и запись в кэш  ("Как по мне предзапись необязательна" - НикитосУбийца2008)
for i in range(-100000, 20):
    f(i)

print(f(20))
```
4. ПРОВЕРКА ДИАПАЗОНА
```py
def f(n):
    if n <= 15:
        return 2 * n * n + 4 * n + 3
    if n > 15 and n % 3 == 0:
        return f(n-1) + n * n + 3
    if n > 15 and n % 3 != 0:
        return f(n - 2) + n - 6


k = 0
# цикл для перебора [1, 1000]
for x in range(1, 1001):
    # если все цифры числа нечётны
    if all(int(i) % 2 != 0 for i in str(f(x))):
        k += 1
print(k)
```
5. НЕОПРЕДЕЛЁННЫЕ ЗНАЧЕНИЯ
```py
def f(n: int) -> int:
    if n <= 5:
        return n
    if n % 5 == 0:
        return n + f(n / 5 + 1)
    return n + f(n + 6)


# найти минимальное n, для которого f(n) > 1000
for n in range(1, 1000):
    # если возможно вычислить, пробуем
    try: 
        if f(n) > 1000:
            print(n)
            break
    except:  # поймано исключение
        pass  # (или просто ... - три точки)
```
